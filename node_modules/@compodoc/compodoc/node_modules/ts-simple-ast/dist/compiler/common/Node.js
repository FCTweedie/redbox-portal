"use strict";
var __generator = (this && this.__generator)/* istanbul ignore next */ || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values)/* istanbul ignore next */ || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var errors = require("./../../errors");
var textSeek_1 = require("./../../manipulation/textSeek");
var insertion_1 = require("./../../manipulation/insertion");
var utils_1 = require("./../../utils");
var Node = /** @class */ (function () {
    /**
     * Initializes a new instance.
     * @internal
     * @param global - Global container.
     * @param node - Underlying node.
     * @param sourceFile - Source file for the node.
     */
    function Node(global, node, sourceFile) {
        this.global = global;
        this._compilerNode = node;
        this.sourceFile = sourceFile;
    }
    Object.defineProperty(Node.prototype, "compilerNode", {
        /**
         * Gets the underlying compiler node.
         */
        get: function () {
            if (this._compilerNode == null)
                throw new errors.InvalidOperationError("Attempted to get information from a node that was removed from the AST.");
            return this._compilerNode;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Releases the node and all its descendants from the cache and ast.
     * @internal
     */
    Node.prototype.dispose = function () {
        try {
            for (var _a = __values(this.getChildren()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                child.dispose();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.disposeOnlyThis();
        var e_1, _c;
    };
    /**
     * Release only this node from the cache and ast.
     * @internal
     */
    Node.prototype.disposeOnlyThis = function () {
        this.global.compilerFactory.removeNodeFromCache(this);
        this._compilerNode = undefined;
    };
    /**
     * Sets the source file.
     * @internal
     * @param sourceFile - Source file to set.
     */
    Node.prototype.setSourceFile = function (sourceFile) {
        this.sourceFile = sourceFile;
        try {
            for (var _a = __values(this.getChildren()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                child.setSourceFile(sourceFile);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var e_2, _c;
    };
    /**
     * Gets the syntax kind.
     */
    Node.prototype.getKind = function () {
        return this.compilerNode.kind;
    };
    /**
     * Gets the syntax kind name.
     */
    Node.prototype.getKindName = function () {
        return ts.SyntaxKind[this.compilerNode.kind];
    };
    /**
     * Gets the compiler symbol.
     */
    Node.prototype.getSymbol = function () {
        var boundSymbol = this.compilerNode.symbol;
        if (boundSymbol != null)
            return this.global.compilerFactory.getSymbol(boundSymbol);
        var typeChecker = this.global.typeChecker;
        var typeCheckerSymbol = typeChecker.getSymbolAtLocation(this);
        if (typeCheckerSymbol != null)
            return typeCheckerSymbol;
        var nameNode = this.compilerNode.name;
        if (nameNode != null)
            return this.global.compilerFactory.getNodeFromCompilerNode(nameNode, this.sourceFile).getSymbol();
        return undefined;
    };
    /**
     * If the node contains the provided range (inclusive).
     * @param pos - Start position.
     * @param end - End position.
     */
    Node.prototype.containsRange = function (pos, end) {
        return this.getPos() <= pos && end <= this.getEnd();
    };
    /**
     * Gets the first child by a condition or throws.
     * @param condition - Condition.
     */
    Node.prototype.getFirstChildOrThrow = function (condition) {
        return errors.throwIfNullOrUndefined(this.getFirstChild(condition), "Could not find a child that matched the specified condition.");
    };
    /**
     * Gets the first child by a condition.
     * @param condition - Condition.
     */
    Node.prototype.getFirstChild = function (condition) {
        try {
            for (var _a = __values(this.getChildrenIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (condition == null || condition(child))
                    return child;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return undefined;
        var e_3, _c;
    };
    /**
     * Gets the last child by a condition or throws.
     * @param condition - Condition.
     */
    Node.prototype.getLastChildOrThrow = function (condition) {
        return errors.throwIfNullOrUndefined(this.getLastChild(condition), "Could not find a child that matched the specified condition.");
    };
    /**
     * Gets the last child by a condition.
     * @param condition - Condition.
     */
    Node.prototype.getLastChild = function (condition) {
        try {
            for (var _a = __values(this.getChildren().reverse()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (condition == null || condition(child))
                    return child;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return undefined;
        var e_4, _c;
    };
    /**
     * Gets the first descendant by a condition or throws.
     * @param condition - Condition.
     */
    Node.prototype.getFirstDescendantOrThrow = function (condition) {
        return errors.throwIfNullOrUndefined(this.getFirstDescendant(condition), "Could not find a descendant that matched the specified condition.");
    };
    /**
     * Gets the first descendant by a condition.
     * @param condition - Condition.
     */
    Node.prototype.getFirstDescendant = function (condition) {
        try {
            for (var _a = __values(this.getDescendantsIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var descendant = _b.value;
                if (condition == null || condition(descendant))
                    return descendant;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return undefined;
        var e_5, _c;
    };
    /**
     * Offset this node's positions (pos and end) and all of its children by the given offset.
     * @internal
     * @param offset - Offset.
     */
    Node.prototype.offsetPositions = function (offset) {
        this.compilerNode.pos += offset;
        this.compilerNode.end += offset;
        try {
            for (var _a = __values(this.getChildren()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                child.offsetPositions(offset);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_6) throw e_6.error; }
        }
        var e_6, _c;
    };
    /**
     * Gets the previous sibling or throws.
     * @param condition - Optional condition for getting the previous sibling.
     */
    Node.prototype.getPreviousSiblingOrThrow = function (condition) {
        return errors.throwIfNullOrUndefined(this.getPreviousSibling(condition), "Could not find the previous sibling.");
    };
    /**
     * Gets the previous sibling.
     * @param condition - Optional condition for getting the previous sibling.
     */
    Node.prototype.getPreviousSibling = function (condition) {
        try {
            for (var _a = __values(this.getPreviousSiblings()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var sibling = _b.value;
                if (condition == null || condition(sibling))
                    return sibling;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return undefined;
        var e_7, _c;
    };
    /**
     * Gets the next sibling or throws.
     * @param condition - Optional condition for getting the next sibling.
     */
    Node.prototype.getNextSiblingOrThrow = function (condition) {
        return errors.throwIfNullOrUndefined(this.getNextSibling(condition), "Could not find the next sibling.");
    };
    /**
     * Gets the next sibling.
     * @param condition - Optional condition for getting the previous sibling.
     */
    Node.prototype.getNextSibling = function (condition) {
        try {
            for (var _a = __values(this.getNextSiblings()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var sibling = _b.value;
                if (condition == null || condition(sibling))
                    return sibling;
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return undefined;
        var e_8, _c;
    };
    /**
     * Gets the previous siblings.
     *
     * Note: Closest sibling is the zero index.
     */
    Node.prototype.getPreviousSiblings = function () {
        var parent = this.getParentSyntaxList() || this.getParentOrThrow();
        var previousSiblings = [];
        try {
            for (var _a = __values(parent.getChildrenIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (child === this)
                    break;
                previousSiblings.splice(0, 0, child);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return previousSiblings;
        var e_9, _c;
    };
    /**
     * Gets the next siblings.
     *
     * Note: Closest sibling is the zero index.
     */
    Node.prototype.getNextSiblings = function () {
        var foundChild = false;
        var nextSiblings = [];
        var parent = this.getParentSyntaxList() || this.getParentOrThrow();
        try {
            for (var _a = __values(parent.getChildrenIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (!foundChild) {
                    foundChild = child === this;
                    continue;
                }
                nextSiblings.push(child);
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_10) throw e_10.error; }
        }
        return nextSiblings;
        var e_10, _c;
    };
    /**
     * Gets the children of the node.
     */
    Node.prototype.getChildren = function () {
        var _this = this;
        return this.compilerNode.getChildren().map(function (n) { return _this.global.compilerFactory.getNodeFromCompilerNode(n, _this.sourceFile); });
    };
    /**
     * @internal
     */
    Node.prototype.getChildrenIterator = function () {
        var _a, _b, compilerChild, e_11_1, e_11, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _d.trys.push([0, 5, 6, 7]);
                    _a = __values(this.compilerNode.getChildren(this.sourceFile.compilerNode)), _b = _a.next();
                    _d.label = 1;
                case 1:
                    if (!!_b.done) return [3 /*break*/, 4];
                    compilerChild = _b.value;
                    return [4 /*yield*/, this.global.compilerFactory.getNodeFromCompilerNode(compilerChild, this.sourceFile)];
                case 2:
                    _d.sent();
                    _d.label = 3;
                case 3:
                    _b = _a.next();
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 7];
                case 5:
                    e_11_1 = _d.sent();
                    e_11 = { error: e_11_1 };
                    return [3 /*break*/, 7];
                case 6:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_11) throw e_11.error; }
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    };
    /**
     * Gets the child syntax list or throws if it doesn't exist.
     */
    Node.prototype.getChildSyntaxListOrThrow = function () {
        return errors.throwIfNullOrUndefined(this.getChildSyntaxList(), "A child syntax list was expected.");
    };
    /**
     * Gets the child syntax list if it exists.
     */
    Node.prototype.getChildSyntaxList = function () {
        var node = this;
        if (utils_1.TypeGuards.isBodyableNode(node) || utils_1.TypeGuards.isBodiedNode(node)) {
            do {
                node = utils_1.TypeGuards.isBodyableNode(node) ? node.getBodyOrThrow() : node.getBody();
            } while ((utils_1.TypeGuards.isBodyableNode(node) || utils_1.TypeGuards.isBodiedNode(node)) && node.compilerNode.statements == null);
        }
        if (utils_1.TypeGuards.isSourceFile(node) || utils_1.TypeGuards.isBodyableNode(this) || utils_1.TypeGuards.isBodiedNode(this))
            return node.getFirstChildByKind(ts.SyntaxKind.SyntaxList);
        var passedBrace = false;
        try {
            for (var _a = __values(node.getChildrenIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (!passedBrace)
                    passedBrace = child.getKind() === ts.SyntaxKind.FirstPunctuation;
                else if (child.getKind() === ts.SyntaxKind.SyntaxList)
                    return child;
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_12) throw e_12.error; }
        }
        return undefined;
        var e_12, _c;
    };
    /**
     * Gets the node's descendants.
     */
    Node.prototype.getDescendants = function () {
        return utils_1.ArrayUtils.from(this.getDescendantsIterator());
    };
    /**
     * Gets the node's descendants as an iterator.
     * @internal
     */
    Node.prototype.getDescendantsIterator = function () {
        var _a, _b, child, _c, _d, childChild, e_13_1, e_14_1, e_14, _e, e_13, _f;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    _g.trys.push([0, 12, 13, 14]);
                    _a = __values(this.getChildrenIterator()), _b = _a.next();
                    _g.label = 1;
                case 1:
                    if (!!_b.done) return [3 /*break*/, 11];
                    child = _b.value;
                    return [4 /*yield*/, child];
                case 2:
                    _g.sent();
                    _g.label = 3;
                case 3:
                    _g.trys.push([3, 8, 9, 10]);
                    _c = __values(child.getDescendantsIterator()), _d = _c.next();
                    _g.label = 4;
                case 4:
                    if (!!_d.done) return [3 /*break*/, 7];
                    childChild = _d.value;
                    return [4 /*yield*/, childChild];
                case 5:
                    _g.sent();
                    _g.label = 6;
                case 6:
                    _d = _c.next();
                    return [3 /*break*/, 4];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_13_1 = _g.sent();
                    e_13 = { error: e_13_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                    }
                    finally { if (e_13) throw e_13.error; }
                    return [7 /*endfinally*/];
                case 10:
                    _b = _a.next();
                    return [3 /*break*/, 1];
                case 11: return [3 /*break*/, 14];
                case 12:
                    e_14_1 = _g.sent();
                    e_14 = { error: e_14_1 };
                    return [3 /*break*/, 14];
                case 13:
                    try {
                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                    }
                    finally { if (e_14) throw e_14.error; }
                    return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    };
    /**
     * Gets the child count.
     */
    Node.prototype.getChildCount = function () {
        return this.compilerNode.getChildCount(this.sourceFile.compilerNode);
    };
    /**
     * Gets the child at the provided position, or undefined if not found.
     * @param pos - Position to search for.
     */
    Node.prototype.getChildAtPos = function (pos) {
        if (pos < this.getPos() || pos >= this.getEnd())
            return undefined;
        try {
            for (var _a = __values(this.getChildrenIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (pos >= child.getPos() && pos < child.getEnd())
                    return child;
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_15) throw e_15.error; }
        }
        return undefined;
        var e_15, _c;
    };
    /**
     * Gets the most specific descendant at the provided position, or undefined if not found.
     * @param pos - Position to search for.
     */
    Node.prototype.getDescendantAtPos = function (pos) {
        var node;
        while (true) {
            var nextNode = (node || this).getChildAtPos(pos);
            if (nextNode == null)
                return node;
            else
                node = nextNode;
        }
    };
    /**
     * Gets the most specific descendant at the provided start position with the specified width, or undefined if not found.
     * @param start - Start position to search for.
     * @param width - Width of the node to search for.
     */
    Node.prototype.getDescendantAtStartWithWidth = function (start, width) {
        var nextNode = this.getSourceFile();
        var foundNode;
        do {
            nextNode = nextNode.getChildAtPos(start);
            if (nextNode != null) {
                if (nextNode.getStart() === start && nextNode.getWidth() === width)
                    foundNode = nextNode;
                else if (foundNode != null)
                    break; // no need to keep looking
            }
        } while (nextNode != null);
        return foundNode;
    };
    /**
     * Gets the start position with leading trivia.
     */
    Node.prototype.getPos = function () {
        return this.compilerNode.pos;
    };
    /**
     * Gets the end position.
     */
    Node.prototype.getEnd = function () {
        return this.compilerNode.end;
    };
    /**
     * Gets the start position without leading trivia.
     */
    Node.prototype.getStart = function () {
        return this.compilerNode.getStart(this.sourceFile.compilerNode);
    };
    /**
     * Gets the first position that is not whitespace.
     */
    Node.prototype.getNonWhitespaceStart = function () {
        return textSeek_1.getNextNonWhitespacePos(this.sourceFile.getFullText(), this.getPos());
    };
    /**
     * Gets the width of the node (length without trivia).
     */
    Node.prototype.getWidth = function () {
        return this.compilerNode.getWidth(this.sourceFile.compilerNode);
    };
    /**
     * Gets the full width of the node (length with trivia).
     */
    Node.prototype.getFullWidth = function () {
        return this.compilerNode.getFullWidth();
    };
    /**
     * Gets the text without leading trivia.
     */
    Node.prototype.getText = function () {
        return this.compilerNode.getText(this.sourceFile.compilerNode);
    };
    /**
     * Gets the full text with leading trivia.
     */
    Node.prototype.getFullText = function () {
        return this.compilerNode.getFullText(this.sourceFile.compilerNode);
    };
    /**
     * Gets the combined modifier flags.
     */
    Node.prototype.getCombinedModifierFlags = function () {
        return ts.getCombinedModifierFlags(this.compilerNode);
    };
    /**
     * @internal
     */
    Node.prototype.replaceCompilerNode = function (compilerNode) {
        this._compilerNode = compilerNode;
    };
    /**
     * Gets the source file.
     */
    Node.prototype.getSourceFile = function () {
        return this.sourceFile;
    };
    /**
     * Gets a compiler node property wrapped in a Node.
     * @param propertyName - Property name.
     */
    Node.prototype.getNodeProperty = function (propertyName) {
        // todo: once filtering keys by type is supported need to (1) make this only show keys that are of type ts.Node and (2) have ability to return an array of nodes.
        if (this.compilerNode[propertyName].kind == null)
            throw new errors.InvalidOperationError("Attempted to get property '" + propertyName + "', but " + "getNodeProperty" + " " +
                "only works with properties that return a node.");
        return this.global.compilerFactory.getNodeFromCompilerNode(this.compilerNode[propertyName], this.sourceFile);
    };
    /**
     * Goes up the tree getting all the parents in ascending order.
     */
    Node.prototype.getAncestors = function () {
        return utils_1.ArrayUtils.from(this.getAncestorsIterator());
    };
    /**
     * @internal
     */
    Node.prototype.getAncestorsIterator = function () {
        var parent;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    parent = this.getParent();
                    _a.label = 1;
                case 1:
                    if (!(parent != null)) return [3 /*break*/, 3];
                    return [4 /*yield*/, parent];
                case 2:
                    _a.sent();
                    parent = parent.getParent();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    };
    /**
     * Get the node's parent.
     */
    Node.prototype.getParent = function () {
        return (this.compilerNode.parent == null) ? undefined : this.global.compilerFactory.getNodeFromCompilerNode(this.compilerNode.parent, this.sourceFile);
    };
    /**
     * Gets the parent or throws an error if it doesn't exist.
     */
    Node.prototype.getParentOrThrow = function () {
        return errors.throwIfNullOrUndefined(this.getParent(), "A parent is required to do this operation.");
    };
    /**
     * Goes up the parents (ancestors) of the node while a condition is true.
     * Throws if the initial parent doesn't match the condition.
     * @param condition - Condition that tests the parent to see if the expression is true.
     */
    Node.prototype.getParentWhileOrThrow = function (condition) {
        return errors.throwIfNullOrUndefined(this.getParentWhile(condition), "The initial parent did not match the provided condition.");
    };
    /**
     * Goes up the parents (ancestors) of the node while a condition is true.
     * Returns undefined if the initial parent doesn't match the condition.
     * @param condition - Condition that tests the parent to see if the expression is true.
     */
    Node.prototype.getParentWhile = function (condition) {
        var node = undefined;
        var nextParent = this.getParent();
        while (nextParent != null && condition(nextParent)) {
            node = nextParent;
            nextParent = nextParent.getParent();
        }
        return node;
    };
    /**
     * Goes up the parents (ancestors) of the node while the parent is the specified syntax kind.
     * Throws if the initial parent is not the specified syntax kind.
     * @param kind - Syntax kind to check for.
     */
    Node.prototype.getParentWhileKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getParentWhileKind(kind), "The initial parent was not a syntax kind of " + ts.SyntaxKind[kind] + ".");
    };
    /**
     * Goes up the parents (ancestors) of the node while the parent is the specified syntax kind.
     * Returns undefined if the initial parent is not the specified syntax kind.
     * @param kind - Syntax kind to check for.
     */
    Node.prototype.getParentWhileKind = function (kind) {
        return this.getParentWhile(function (n) { return n.getKind() === kind; });
    };
    /**
     * Gets the last token of this node. Usually this is a close brace.
     */
    Node.prototype.getLastToken = function () {
        var lastToken = this.compilerNode.getLastToken(this.sourceFile.compilerNode);
        if (lastToken == null)
            throw new errors.NotImplementedError("Not implemented scenario where the last token does not exist.");
        return this.global.compilerFactory.getNodeFromCompilerNode(lastToken, this.sourceFile);
    };
    /**
     * Gets if this node is in a syntax list.
     */
    Node.prototype.isInSyntaxList = function () {
        return this.getParentSyntaxList() != null;
    };
    /**
     * Gets the parent if it's a syntax list or throws an error otherwise.
     */
    Node.prototype.getParentSyntaxListOrThrow = function () {
        return errors.throwIfNullOrUndefined(this.getParentSyntaxList(), "Expected the parent to be a syntax list.");
    };
    /**
     * Gets the parent if it's a syntax list.
     */
    Node.prototype.getParentSyntaxList = function () {
        var parent = this.getParent();
        if (parent == null)
            return undefined;
        var pos = this.getPos();
        var end = this.getEnd();
        try {
            for (var _a = __values(parent.getChildren()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (child.getPos() > pos || child === this)
                    return undefined;
                if (child.getKind() === ts.SyntaxKind.SyntaxList && child.getPos() <= pos && child.getEnd() >= end)
                    return child;
            }
        }
        catch (e_16_1) { e_16 = { error: e_16_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_16) throw e_16.error; }
        }
        return undefined; // shouldn't happen
        var e_16, _c;
    };
    /**
     * Gets the child index of this node relative to the parent.
     */
    Node.prototype.getChildIndex = function () {
        var parent = this.getParentSyntaxList() || this.getParentOrThrow();
        var i = 0;
        try {
            for (var _a = __values(parent.getChildren()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                if (child === this)
                    return i;
                i++;
            }
        }
        catch (e_17_1) { e_17 = { error: e_17_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_17) throw e_17.error; }
        }
        /* istanbul ignore next */
        throw new errors.NotImplementedError("For some reason the child's parent did not contain the child.");
        var e_17, _c;
    };
    /**
     * Gets the indentation text.
     */
    Node.prototype.getIndentationText = function () {
        var sourceFileText = this.sourceFile.getFullText();
        var startLinePos = this.getStartLinePos();
        var startPos = this.getStart();
        var text = "";
        for (var i = startPos - 1; i >= startLinePos; i--) {
            var currentChar = sourceFileText[i];
            switch (currentChar) {
                case " ":
                case "\t":
                    text = currentChar + text;
                    break;
                case "\n":
                    return text;
                default:
                    text = "";
            }
        }
        return text;
    };
    /**
     * Gets the next indentation level text.
     */
    Node.prototype.getChildIndentationText = function () {
        if (utils_1.TypeGuards.isSourceFile(this))
            return "";
        return this.getIndentationText() + this.global.manipulationSettings.getIndentationText();
    };
    /**
     * Gets the position of the start of the line that this node starts on.
     */
    Node.prototype.getStartLinePos = function () {
        var sourceFileText = this.sourceFile.getFullText();
        return textSeek_1.getPreviousMatchingPos(sourceFileText, this.getStart(), function (char) { return char === "\n"; });
    };
    /**
     * Gets if this is the first node on the current line.
     */
    Node.prototype.isFirstNodeOnLine = function () {
        var sourceFileText = this.sourceFile.getFullText();
        var startPos = this.getStart();
        for (var i = startPos - 1; i >= 0; i--) {
            var currentChar = sourceFileText[i];
            if (currentChar === " " || currentChar === "\t")
                continue;
            if (currentChar === "\n")
                return true;
            return false;
        }
        return false;
    };
    Node.prototype.replaceWithText = function (textOrWriterFunction) {
        var newText = utils_1.getTextFromStringOrWriter(this.global.manipulationSettings, textOrWriterFunction);
        if (utils_1.TypeGuards.isSourceFile(this)) {
            this.replaceText([this.getPos(), this.getEnd()], newText);
            return this;
        }
        var parent = this.getParentSyntaxList() || this.getParentOrThrow();
        var childIndex = this.getChildIndex();
        try {
            insertion_1.insertIntoParent({
                parent: parent,
                childIndex: childIndex,
                insertItemsCount: 1,
                insertPos: this.getStart(),
                newText: newText,
                replacing: {
                    nodes: [this],
                    textLength: this.getWidth()
                }
            });
        }
        catch (err) {
            throw new errors.InvalidOperationError("replaceWithText" + " currently only supports replacing the current node " +
                "with a single new node. If you need the ability to replace it with multiple nodes, then please open an issue.\n\nInner error: " + err);
        }
        return parent.getChildren()[childIndex];
    };
    /**
     * Gets the children based on a kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getChildrenOfKind = function (kind) {
        return this.getChildren().filter(function (c) { return c.getKind() === kind; });
    };
    /**
     * Gets the first child by syntax kind or throws an error if not found.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstChildByKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getFirstChildByKind(kind), "A child of the kind " + ts.SyntaxKind[kind] + " was expected.");
    };
    /**
     * Gets the first child by syntax kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstChildByKind = function (kind) {
        return this.getFirstChild(function (child) { return child.getKind() === kind; });
    };
    /**
     * Gets the first child if it matches the specified syntax kind or throws an error if not found.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstChildIfKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getFirstChildIfKind(kind), "A first child of the kind " + ts.SyntaxKind[kind] + " was expected.");
    };
    /**
     * Gets the first child if it matches the specified syntax kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstChildIfKind = function (kind) {
        var firstChild = this.getFirstChild();
        return firstChild != null && firstChild.getKind() === kind ? firstChild : undefined;
    };
    /**
     * Gets the last child by syntax kind or throws an error if not found.
     * @param kind - Syntax kind.
     */
    Node.prototype.getLastChildByKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getLastChildByKind(kind), "A child of the kind " + ts.SyntaxKind[kind] + " was expected.");
    };
    /**
     * Gets the last child by syntax kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getLastChildByKind = function (kind) {
        return this.getLastChild(function (child) { return child.getKind() === kind; });
    };
    /**
     * Gets the last child if it matches the specified syntax kind or throws an error if not found.
     * @param kind - Syntax kind.
     */
    Node.prototype.getLastChildIfKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getLastChildIfKind(kind), "A last child of the kind " + ts.SyntaxKind[kind] + " was expected.");
    };
    /**
     * Gets the last child if it matches the specified syntax kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getLastChildIfKind = function (kind) {
        var lastChild = this.getLastChild();
        return lastChild != null && lastChild.getKind() === kind ? lastChild : undefined;
    };
    /**
     * Gets the previous sibiling if it matches the specified kind, or throws.
     * @param kind - Kind to check.
     */
    Node.prototype.getPreviousSiblingIfKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getPreviousSiblingIfKind(kind), "A previous sibling of kind " + ts.SyntaxKind[kind] + " was expected.");
    };
    /**
     * Gets the next sibiling if it matches the specified kind, or throws.
     * @param kind - Kind to check.
     */
    Node.prototype.getNextSiblingIfKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getNextSiblingIfKind(kind), "A next sibling of kind " + ts.SyntaxKind[kind] + " was expected.");
    };
    /**
     * Gets the previous sibling if it matches the specified kind.
     * @param kind - Kind to check.
     */
    Node.prototype.getPreviousSiblingIfKind = function (kind) {
        var previousSibling = this.getPreviousSibling();
        return previousSibling != null && previousSibling.getKind() === kind ? previousSibling : undefined;
    };
    /**
     * Gets the next sibling if it matches the specified kind.
     * @param kind - Kind to check.
     */
    Node.prototype.getNextSiblingIfKind = function (kind) {
        var nextSibling = this.getNextSibling();
        return nextSibling != null && nextSibling.getKind() === kind ? nextSibling : undefined;
    };
    /**
     * Gets the parent if it's a certain syntax kind.
     */
    Node.prototype.getParentIfKind = function (kind) {
        var parentNode = this.getParent();
        return parentNode == null || parentNode.getKind() !== kind ? undefined : parentNode;
    };
    /**
     * Gets the parent if it's a certain syntax kind of throws.
     */
    Node.prototype.getParentIfKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getParentIfKind(kind), "A parent with a syntax kind of " + ts.SyntaxKind[kind] + " is required to do this operation.");
    };
    /**
     * Gets the first ancestor by syntax kind or throws if not found.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstAncestorByKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getFirstAncestorByKind(kind), "A parent of kind " + ts.SyntaxKind[kind] + " is required to do this operation.");
    };
    /**
     * Get the first ancestor by syntax kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstAncestorByKind = function (kind) {
        try {
            for (var _a = __values(this.getAncestors()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var parent = _b.value;
                if (parent.getKind() === kind)
                    return parent;
            }
        }
        catch (e_18_1) { e_18 = { error: e_18_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_18) throw e_18.error; }
        }
        return undefined;
        var e_18, _c;
    };
    /**
     * Gets the descendants that match a specified syntax kind.
     * @param kind - Kind to check.
     */
    Node.prototype.getDescendantsOfKind = function (kind) {
        return this.getDescendants().filter(function (c) { return c.getKind() === kind; });
    };
    /**
     * Gets the first descendant by syntax kind or throws.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstDescendantByKindOrThrow = function (kind) {
        return errors.throwIfNullOrUndefined(this.getFirstDescendantByKind(kind), "A descendant of kind " + ts.SyntaxKind[kind] + " is required to do this operation.");
    };
    /**
     * Gets the first descendant by syntax kind.
     * @param kind - Syntax kind.
     */
    Node.prototype.getFirstDescendantByKind = function (kind) {
        try {
            for (var _a = __values(this.getDescendantsIterator()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var descendant = _b.value;
                if (descendant.getKind() === kind)
                    return descendant;
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_19) throw e_19.error; }
        }
        return undefined;
        var e_19, _c;
    };
    return Node;
}());
exports.Node = Node;

//# sourceMappingURL=Node.js.map
